---
layout: life
title: Transactions
date: 2019-02-02 18:03:24
tags:
-- 论文研究
---

Life beyond Distributed Transactions 论文研究 Amazon的论文，分布式事务

<!--more-->

这篇paper主要按照三个目标进行展开。

* 描述可伸缩系统
* 深入理解趋近于无穷的可伸缩系统
* 描述一些通用的分布式事务模型

# Scale-Agnosticism

首先读了大概三四页paper，然后并没有看懂咋回事，主要卡在了这个名次上了，google一下

The word agnostic comes from the Greek a-, meaning without and gnōsis, meaning knowledge. In IT, that translates to the ability of something to function without “knowing” the underlying details of a system that it is working within.  As with interoperability, agnosticism is typically enabled by either compliance with widely-used standards or added elements (such as coding) that will enable one system to function in a variety of environments.

就是上面的解释了，大致的意思就是这个angostic是个希腊词汇，在一个系统上我们并不需要知道某一个底层实现的具体方法，我们就可以使用这个底层系统地能力，通常来说，一个不可知系统的底层可以用于管理多种元素，这里我认为就是机器啦，然后并且可以让一个系统中的某一个行为在多种环境下都可以呈现相同的结果。

比较绕，后来我想到了封装，其实这个应该就是伸缩隐藏，简单来说，我们的应用系统并不需要知道底层的扩展是怎么做的，但是可以实现伸缩。这篇论文主要写的是关于分布式事务，那么我们实现事务的时候可以单机也可以集群，那么一个符合伸缩隐藏的事务系统，应该是不关心底层到底有多少个数据节点的，只要能给上层应用提供足够的事务管理原语就好了，这样的一个事务管理器或者是其他的什么叫法的东西，就是一个伸缩隐藏的事务管理系统。

当然还有一个最常见的东西，MapReduce就是一个伸缩隐藏的编程方式

# 必要满足的假设

paper的作者以下面几个假设开始进行分析，一个事务管理器应该必须满足以下的假设和操作

## 应用分层和伸缩不可知性
通常设计应用都会按照下面的架构模型来设计，其实我觉得用VFS来描述更科学一点，upper层是伸缩无关的代码，而中间一层提供了伸缩编程抽象，而lower代码就是对伸缩抽象的实现了，例如VFS其实就是这样的一个东西，我们使用Linux Posix 接口编写文件处理程序，然后VFS是一个文件操作抽象层，而如果下面换成NFS的话，那么就实现了伸缩不可知性，因为NFS到底是一块还是多块磁盘我们是并不关心的，专心实现业务逻辑层。

![](http://ww1.sinaimg.cn/mw690/00666n22ly1fzs9yuj8dpj30ik08w40f.jpg)

## 事务串行化的作用域 

用过Spring之类的web框架，它里面的事务管理器就是一个线程管理器，管理着事务上下文，然后可以多条SQL顺序执行，注意这个顺序，这个顺序就是事务的串行化。但是在分布式场景下还是很难受的。因为问题出现在哪了，出现在了，一个线程一个事务可以保证很多关于事务的信息可以互相共享，因为一个内存映射空间嘛，ThreadLocal，要是用Goroutine好像就要用Context包了。

分布式的情景更麻烦，所以这里作者假设了事务串行化的作用域范围。认为在单独一台机器和一个集群内事务是很好控制的，因为我们可以用一些手段把他们紧密的耦合在一起，从而可以让每一个事务中的原子操作又一个统一的作用域可见性。但是出现了跨越集群的事务的时候，那么有的原子操作可能就不会那么轻松的实现原子操作了。然后这些操作集合就成了一个个的不相交集合了，这个时候，其实内存可见性就这样的被不相交关系给隔离开了，也就是提交和回滚并不能做到原子化事务的作用啦。

## 更多的应用采用幂等消息 

幂等重要性基本不用说了，一个事务管理器，肯定是能容忍分布式条件下的消息重试的。

## 总结一下

上面的假设，提出了一个事务管理器的三点要求

* 能做到对应用系统的侵入性最小
  * 伸缩的扩展的隐藏，不需要知道细节
  * 哪怕多台机器分布式事务，也应该和单台机器事务一致的体现
* 事务能串行化运行
  * 事务管理器能容忍事务不相交集
* 接受多次事务消息
  * 事务控制信息会被包装成消息放入消息总线内
  * 一条消息是否被消费不能被追踪，但是应该能保证对重试的容忍


# 可选的满足条件

作者拿出了一些可选条件，供不同的事务管理器来实现和选择，比必要假设更宽泛。


总结一下 

* 实体 这里的实体不是所谓的什么ER内的实体，而是独立的系统代称，也就是一个业务系统就是一个实体空间
* 事务控制域 修改多个实体所在的程序运行上下文
* 原子事务 这个就不说了 满足 ACID的事务啦 
* 参与者，也就是多个系统交互的时候每个系统都叫做一个参与者

## 可选条件

* 可伸缩的应用使用唯一的KEY标识参与业务的实体们

paper里面说是让所有的实体生存在一个事务控制域内，就是让多个实体必须在一个域内进行修改。

* 原子事务不能跨越实体

何为不能跨越实体呢，其实简单来说就是我们对一个系统内的多个实体进行操作的时候，不能影响其他系统的实体，比如外卖系统和账户系统，我们修改外卖系统的订单同时不能在一个原子事务内修改账户余额，怎么修改呢，那么就用后面的消息通知方案

* 消息用来定位实体

分布式消息通常用来定位业务实体，这个不多说 

* 实体要管理参与者状态

管理状态主要的目的是用来做幂等简单来说就是用来记录这个交互消息是否被处理


# 事务实体 

最开始很难理解这个概念，后面对照Spring的事务管理方案，还有Tcc-Transaction 设计慢慢有了感觉，这就是科研的味道吗？论文所谓的事务实体，其实我看来就是每个伸缩控制层，因为我们上文说了伸缩隐藏性，伸缩隐藏举个例子来说，就是我们修改了默认的Spring的事务管理器实现，我们的应用代码仍然用原来的一套，但是下面一层的事务切面被修改为了分布式事务，我们不知道一个事务会怎样的被执行，同样我们也不知道到底有多少台数据库在进行CURD我们只需要知道我们CURD那些表就可以了，那么事务实体是什么，就是在分布式事务系统内保证这些隐藏和封装性的实体啦，也就是有了下面这些实体的保证，这些实体和业务无关，这些实体的交互，就可以让一个分布式事务可以得到有效的原子保证，当然原子保证可能就是和TCC一样的最终一致，实现最大努力通知的模式。

## 事务序列化不相交集合

这个事务实体，其实就是组织了多个事务序列化的时候的事务控制域，保证了被执行的SQL哪怕不是在一台机器上运行，但是在逻辑上看仍然是在同一个事务控制域内，那么我们可以使用树来组织这个作用域关系，和编译原理内的作用域思路一样的。

## 唯一Key 实体

这个实体保证的是什么，保证的是一个分布式事务下的所有SQL执行实体会被唯一的组织。说白了就是用来表示一个分布式事务，用来trace的。这里业界实现是不是就是类似Snowflake之类的东西啦

## 分割和业务实体 

这里分割的概念其实就是SQL的执行顺序问题，因为SQL的执行会被打散到多台服务器上，但是我们可以根据KEY找到SQL到底属于哪个分布式事务，所以这里其实就是再分配的概念，让每个事务SQL可以按照顺序执行。组织上建议使用HASH这种方案来进行查找，啊哈我感觉还是按照树组织更合理。

## 原子事务实体

我们必须要保证一个原子事务应该被原子的执行和回滚等其他操作，那么一个原子事务的操作绝对是不能跨越执行服务器的，也就是我们尽可能保证一个原子事务内的一组SQL被同一台机器执行，那么这里采用HASH是没问题的，能保证一组SQL拥有唯一的key。这样我们在分配SQL执行的时候，就可以首先按照分布式事务的key进行排序，然后在按照原子事务的key打到他该去的服务器上去执行。

果然论文下面就是这样的一个东西，主key和副key的概念

![](http://ww1.sinaimg.cn/mw690/00666n22ly1fzw28tw7zcj30l808mgn7.jpg)

the primary index and alternate index information must reside within the same scope of serializability

就是这句话，一个主要的key 也就是主key和替代key，副key的信息必须属于同一个事务控制域，啊哈，有没有发现什么特别的东西，这里的抽象就是，将多台执行器放入了一个scope中成为了一个事务控制域，副key保证一个原子事务的SQL组被同一台机器进行执行，而主key保证了在一个域下面执行。


## 总结

到目前为止大概包含了很多的分布式事务的特征，当然除了事务本来应该保持的性质之外，还有一些其他的事务特性，比如了解了事务控制域，事务实体，原子事务，事务参与者。

那么分布式事务的本质是个什么东西呢？

就目前所收获的新知识来看，数据库事务是最长接触到的一种东西，当然这些事务仍然包含一些对文件操作，同样的需要保证ACID，不过一个SQL系统底层实现上也就是对文件或者磁盘进行CURD，我们明白了一个分布式事务是由多个类似数据库事务一样的原子事务组成，数据库事务为什么是原子的呢？或者说为什么分布式事务的第一层要求就是要数据库事务是原子的呢？

这里参考树的定义，我认为一个根节点是一个分布式事务节点，分布式事务下面有很多的原子事务节点层，这些节点层的下面节点又包含了多条SQL语句节点，这些SQL语句肯定是原子的，那么这个毫无疑问，所以可以得到这样的一张图

![](http://ww1.sinaimg.cn/mw690/00666n22ly1fzw1nk23ujj310u0n6jte.jpg)

我认为一个分布式事务是这样被组织起来的，圆代表一个分布式事务，矩形代表一个原子事务，三角代表一个SQL语句，或者是原子操作。

那么我们保证SQL事务很简单，同样保证一个原子事务也很简单，无非beagin 和 commit 和 rollback ，但是分布式事务怎么管理呢，不说别的，首先就要进行存储，我看TCC-Transaction 的实现里面就用ZK还有Redis等一些分布式工具保存了一个分布式事务，然后每个分布式事务，同样保证了原子事务的隔离属性，具体参考Spring 的事务隔离方案，然后对这些事务管理就可以啦。所以到这里应该能简单的设计一个事务管理器出来了。



# 事务消息 

