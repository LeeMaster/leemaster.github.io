---
title: Rust 中令人迷惑的所有权和生命周期
date: 2019-05-06 11:10:56
tags:
- Rust
---

# 编程语言中的值和引用

在任何一个语言中都有值和引用的概念，这是一个很简单的概念，但是也很容易让人忽略内存本质的概念。

<!--more-->

冯诺伊曼体系，以内存为中心的计算机体系结构，提供了这两个概念存在的理论基础。

什么是值，什么是引用，并没有一个很良好的定义，因为在不同的语言中行为是不同的。在解释这个事情之前，首先解释一下在运行时内存的粗略划分。大家应该都知道在运行时有两个内存区域，一个是栈空间，一个是堆空间。

## 栈空间

栈空间，在运行时用于存储临时变量，包括传递到函数内实际参数和在函数内部出现的生命语句，都有可能产生栈上变量，而变量一定是有值的，哪怕是NULL这种零值。这个值存在哪呢？

这个值可能存在在栈空间，也有可能存在在堆空间。比如机器的字长是32位的时候，那么一个栈空间的分配单位自然也是32位，而32位足够来放一个32位整型的值，所以这个时候，值是存在在栈空间的，当然长整型也是可以的。那么在C语言中常见的 **char\*** 呢？有的小伙伴可能会想到，一个char是8位，那么三个char的字符串就放在栈空间不就好了吗？很显然这样会给编译器带来额外的解释翻译负担，所以 **char\*** 其实是一个32位的地址，用于指向堆空间的某块内存。这时会将堆空间的地址给程序中的变量。在栈空间进行存储。

大部分语言实现栈空间存储地址的时候，都会封装一个对象进行存储形如：

```C
struct reference{
  void * ptr ;
}
```

栈上分配变量，应该是顺序分配的，也就是按照声明顺序进行分配地址空间。

## 堆空间

堆空间，自然是很大的空间，在堆空间分配内存，可能并不连续，比如经典的数据结构链表。

那么堆空间的内存应该是可以被访问的，如何访问呢？首先需要得到一个地址，并且拿到类型，我们讨论一下数组类型，这个类型需要一个地址，需要一个长度，也需要一个内部元素类型，知道这三个元信息就可以对数组进行访问了。 大多数的实现应该和下方C代码一样的形式。

```C
struct arr_ref {
  void * ptr;
  size_t len;
  size_t type_len;
}
```

当我们拥有一个arr_ref 类型的时候，就可以对数组进行访问了，包括遍历和获取其中的值，修改其中的值。

## 从栈到堆

在上面解释了，什么是栈，什么是堆，那么从栈到堆是一个必然的过程，因为极少数的可能性是，直接使用栈就足够满足一个函数的内存需求的。从栈到堆其实就是一个解开引用，获取一些用于访问内存的元信息。

比如经常用的元信息：

* 地址
* 长度
* 读写权限

那么这些元信息，基本都是基本类型，也就是一个int或者一个long可以存储的类型，自然编译器就会让这些变量去栈上分配内存，并生成一个从栈到堆的凭证。这里我认为 **arr_ref** 类型就是一个访问内存的凭证。

所以从栈到堆，是一个对引用进行解析，并最终返回使用引用操作内存的结果。

# Rust 所有权和Move 语义

Rust 不允许使用未经初始化的变量，是在编译期进行解决和实现的。接下来主要讨论Rust中的值，可以认为是在栈上进行分配释放的变量。

## 初始化和移动初步

在Rust 中，当程序运行时，一个值只能有一个owner ，语义表明一个值只能被一个变量所拥有，这里的值包括，Vec的凭证，所有基本类型，Vec的分配比较特殊。Vec 中的元素会存放到堆空间中去，但是内存凭证会存放到栈空间中去。当使用一个Vec的时候

```rust
let v = vec![1,2,3,4];
```

变量v 是拥有一个Vec的所有权的，拥有的是一个vec_ref类型的值的所有权。

```C
struct vec_ref {
  void * buffer;
  size_t capcity;
  size_t length;
}
```

当出现下面情况的时候 

```rust
let v2 = v;
```

这个时候，编译器会将代码转换成如下的c代码的语义。

```C
int[] v2 = v;
v = NULL;
```

这个时候，v变量变得不可用了，但是C的编译器并不能在编译时检查到，v已经变成了NULL，而接下来使用v进行操作的时候，就会出现悬垂问题。

## 自动释放

Rust 使用scope 来决定一个变量中的值是否释放。scope 就是编译中的变量作用域概念。

例如 ：

```rust
let v = vec![1,2,3];
{
  let s = v;
}
println!("{}",v);
```

这段代码中，因为v已经将所有权交给了s，但是s的作用域只在，全局作用域的下面的子作用域，而通过上面的分析来看，v已经为NULL了，Rust 编译器会检查这个问题，从而抛错误出来；

而s 也会在离开作用域的时候被释放掉。上述代码在C中语义如下；

```C
arr_ref v = arr_ref{ptr,3,3};

{
  arr_ref s = v;
  v = NULL;
  s = NULL;
  free(s.ptr);
}

// 使用 v  自然出错
```

## 再看移动

Rust 中大多数的类型，在进行为变量绑定值的过程和传递函数参数的过程中，都不会执行拷贝动作，而是使用move代替，将原有的值带入一个新的作用域中。变量离开作用域，值也被销毁。

但是在上面代码中，vec会出现移动后调用失败现象，那么对于基本类型呢？

```rust
let v : i32 = 1;
{
  let s : i32 = v;
}
println!("{}",v);
```

这个代码并不会产生任何编译器异常，因为i32类型实现了Copy 特性，用于拷贝，s 和 v 变量是两个不同的地址，同时值是相同的，也就是拷贝的语义。如果实现了拷贝Copy 的类型在进行赋值和函数传递的时候，并不会出现移动，而是用拷贝代替。

### 嵌套结构移动

在C++ 中下面的操作是很正常的。

```c++
vector<string> vec;
vec.psuh_back("sss");
vec.push_back("sss");

string a = vec[0];
```

但是Rust中同样的写法会出错，这个原因解释起来可以很形象，我们思考一下，在孤儿院中都是没有父母的小孩，那么我们可以收养一个孤儿，但是我们并不能收养一个有父母的小孩，在Rust中透过父亲来移动一个孩子的所有权。

```rust
struct P {
  c : i32
}

let p = P{c:15};

let child = p.c;

```

但是上面的代码是可以通过编译的，因为i32实现了Copy语义，并不会发生移动，但是如果移动string类型的时候，因为string类型并没有实现Copy，因此这个string的所有权是归Vec所有的，自然通过父亲来拿儿子的时候会法生产错误。

因为Vec实现了Index特性，所以会有一些限制。
