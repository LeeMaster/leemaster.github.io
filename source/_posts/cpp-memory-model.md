---
title: C++ 存储类型（搬运了一波）
date: 2019-11-09 20:46:35
categories:
- C++
---

C++ 数据存储的模型

<!--more-->

# 单独编译

在C++中声明和定义是分离的，声明的意义是为了编译器构建符号表，而定义则是定义各个数据类型，编译器处理完了符号表，会根据定义进行内存分配和指令分配，正是这个性质，导致C++好像很难学的样子，但是事实他就是有点难学。

头文件会在被引入源文件的时候，进行展开，凡是需要被展开的东西统统都塞入头文件就对了，比如常见的宏、inline函数。当然模板的定义和声明是不能分割的，如果说OOP是用来抽象数据模型的，那么模板就是用来抽象算法的，回顾算法的定义，算法其实是一系列用来解决问题的指令序列，模板自然要将声明和定义绑定在一起放在头文件里，而模板的具体化和实例化，并不是要讨论的重点，记住这玩意放入头文件就可以啦。

编译后的结果进行链接才能生成各种构建物，用于构建软件世界，比如可执行文件和动态链接库等等等。所以这里要引入一个比较重要的概念了——编译单元。

什么是编译单元呢？我的理解是，对于一个大规模工程，是一个一个的源文件构成的，那么在C/C++中这些源文件组成了一个又一个的编译单元，编译单元可以认为是编译器可以处理的最小的源文件单位。既然是编译的最小单元，那么在每一个单元中都会有编译原理中经典的作用域问题。

# 存储持续性

* 自动存储持续性，这个其实很好理解，进入作用域生效，离开作用域失效的变量，拥有的都是自动存储持续性，参考auto关键字。
* 静态存储持续性，既然是静态的，那么在编译时被分配了内存，这个内存位置在整个程序运行过程中都会生效。
* 线性存储持续性，我觉得这个词用的非常准确，thread_local 定义的变量统统都是线性的存储持续性，因为只能被一个线程可见，而且和整个线程的生命周期一样长。
* 动态存储持续性，指针变量，这种直接指向动态内存的变量拥有的都是动态存储持续性，也是最难搞的东西，内存泄漏的元凶之一。

# 链接性

关于编译单元的概念已经解释清楚了，在整个工程构建的过程中，可以认为将所有的代码转换成为一个超级长的汇编代码文件，那么在整个汇编文件中，有一部分从一个文件来，有一部分从另外一个文件来，所以自然是有方法让从文件一来的代码访问来自文件二来的代码中的变量和函数，这里就涉及到了链接性了。

## 静态持续，外部链接

静态变量外部链接在定义和使用上有两个条件

* 不使用static关键字进行修饰
* 在其他文件中使用extern关键字进行再次声明

C++使用了单定义规则，变量只能有一次定义，分为两种声明

* 定义声明，这种声明，会要求编译器进行内存分配
* 引用声明，这种声明，只是引用，主要是为了解决编译器的符号表建立过程，如果引用了外部不存在的变量，那么会在链接的过程中报错。


## 静态持续，内部链接

直接使用static关键字标记，这个变量就只能在当前文件内可见了，也就是所谓的内部链接性。

## 静态持续，无链接性

函数内的变量使用static进行修饰，那么这个变量就是局部的静态变量，只能在当前函数内使用，自然没有链接性了。

# 说明符和限定符

## CV限定符

* const 
* volatile 

被const修饰的变量，语义是当前被修饰的内存不能再被修改了，属于对物理常量性的一个描述。volatile属于强制内存取值，避免编译器使用某些优化手段导致在并发情况下，对某一变量的读取是不一致的。

mutable修饰符

```cpp
struct const_struct{
  int a ;
  mutable int accesses;
}
```

如上述代码一样，尽管可以使用const来修饰某个结构变量，但是其中的mutable修饰的变量仍是可以被修改的，这个特性在并发编程的时候会被用到。

但是const会修改变量的链接性，当全局变量（外部链接性）被const修饰了之后，那么这个变量就变成了内部链接性，但是对于工程来讲，常量确实应该是一个编译单元应该具有的东西，如果需要做全局的常量。可以通过 extern + const 组合修饰来使用。


